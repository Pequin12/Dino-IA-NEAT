"""
Dino Run con NEAT + Pygame
Archivo: dino_neat.py
Explicación rápida:
- Usa neat-python (pip install neat-python) y pygame (pip install pygame).
- Ejecuta: python dino_neat.py
- El script crea un archivo de configuración NEAT por defecto si no existe.
- Muestra múltiples agentes (cuadrados) aprendiendo a saltar cactus y esquivar pájaros.
- Arriba a la derecha hay una mini-vista que dibuja la red neuronal de la "best genome" de la generación actual.
  Si varias redes controlan agentes en la misma posición, se elige una al azar para mostrar.
- Obstáculos aparecen aleatoriamente con una distribución no-constante (intervalos aleatorios tipo exponencial) para aproximar el ritmo del juego original.

Nota: gráficos simples (cuadrados). El código está pensado para ser legible y fácil de modificar.
"""

import pygame
import neat
import os
import random
import math
import time
import pickle

# --------------------------- CONFIG --------------------------------
WINDOW_WIDTH = 800
WINDOW_HEIGHT = 400
FPS = 60
GROUND_Y = 300

# Dino parameters
DINO_X = 50
DINO_SIZE = 30
JUMP_V = -10
GRAVITY = 0.6

# Obstacles
BASE_SPEED = 8
MIN_SPAWN_MS = 700
MAX_SPAWN_MS = 2200

# Visualization
POP_MAX_DRAW = 50  # max agents to draw each frame (to keep it performant)

# ---------------------------------------------------------------------

# If neat config file doesn't exist, write a default one.
DEFAULT_NEAT_CONFIG = """

[NEAT]
fitness_criterion     = max
fitness_threshold     = 20000
pop_size              = 300
reset_on_extinction   = False

[DefaultGenome]
# node activation options
activation_default      = tanh
activation_mutate_rate  = 0.1
activation_options      = tanh sigmoid relu

# node aggregation options
aggregation_default     = sum
aggregation_mutate_rate = 0.1
aggregation_options     = sum

# node bias options
bias_init_mean          = 0.0
bias_init_stdev         = 1.0
bias_max_value          = 30.0
bias_min_value          = -30.0
bias_mutate_power       = 0.5
bias_mutate_rate        = 0.7
bias_replace_rate       = 0.1

# genome compatibility options
compatibility_disjoint_coefficient = 1.0
compatibility_weight_coefficient   = 0.5

# connection add/remove rates
conn_add_prob           = 0.5
conn_delete_prob        = 0.5

# connection enable options
enabled_default         = True
enabled_mutate_rate     = 0.01

feed_forward            = True
initial_connection      = unconnected

# node add/remove rates
node_add_prob           = 0.2
node_delete_prob        = 0.2

# network parameters
num_hidden              = 0
num_inputs              = 5
num_outputs             = 1

# node response options
response_init_mean      = 1.0
response_init_stdev     = 0.0
response_max_value      = 30.0
response_min_value      = -30.0
response_mutate_power   = 0.0
response_mutate_rate    = 0.0
response_replace_rate   = 0.0

# connection weight options
weight_init_mean        = 0.0
weight_init_stdev       = 1.0
weight_max_value        = 30
weight_min_value        = -30
weight_mutate_power     = 0.5
weight_mutate_rate      = 0.8
weight_replace_rate     = 0.1

[DefaultSpeciesSet]
compatibility_threshold = 3.0

[DefaultStagnation]
species_fitness_func = max
max_stagnation       = 20
species_elitism      = 2

[DefaultReproduction]
elitism            = 2
survival_threshold = 0.2
"""


class Dino:
    def __init__(self):
        self.x = DINO_X
        self.y = GROUND_Y - DINO_SIZE
        self.size = DINO_SIZE
        self.vel_y = 0
        self.is_jumping = False
        self.alive = True
        self.score = 0

    def update(self):
        # physics
        self.vel_y += GRAVITY
        self.y += self.vel_y
        if self.y >= GROUND_Y - self.size:
            self.y = GROUND_Y - self.size
            self.vel_y = 0
            self.is_jumping = False

    def jump(self):
        if not self.is_jumping and self.y >= GROUND_Y - self.size - 1:
            self.vel_y = JUMP_V
            self.is_jumping = True

    def rect(self):
        return pygame.Rect(int(self.x), int(self.y), self.size, self.size)


class Obstacle:
    def __init__(self, kind='cactus'):
        self.kind = kind
        self.speed = BASE_SPEED
        if kind == 'cactus':
            self.width = random.randint(20, 28)
            self.height = random.randint(30, 40)
            self.y = GROUND_Y - self.height
        else:  # bird
            self.width = 34
            self.height = 24
            # bird flies at different heights
            self.y = GROUND_Y - self.height - random.choice([70, 100, 40])
        self.x = WINDOW_WIDTH + random.randint(0, 200)

    def update(self):
        self.x -= self.speed

    def rect(self):
        return pygame.Rect(int(self.x), int(self.y), self.width, self.height)


def spawn_obstacle():
    # roughly mimic Dino run mixing cacti and birds
    kind = 'cactus' if random.random() < 0.75 else 'bird'
    return Obstacle(kind)


# Helper to compute time until next spawn (randomized, not constant)
def next_spawn_time_ms():
    # Use exponential distribution to produce jittery intervals similar to human gameplay
    # mean around 1400ms but limited
    lam = 1 / 1.4
    val = random.expovariate(lam) * 1000
    return max(MIN_SPAWN_MS, min(MAX_SPAWN_MS, int(val)))


# Draw network small visualization in top-right
def draw_network(surface, genome, config, topleft=(580, 10), size=(210, 140)):
    # We'll draw nodes in layers: inputs -> hidden (if any) -> outputs
    # For simplicity, place input nodes vertically on left, outputs on right.
    font = pygame.font.SysFont(None, 12)
    x0, y0 = topleft
    w, h = size

    # collect nodes
    node_keys = list(genome.nodes.keys())
    inputs = [k for k in node_keys if k < config.genome_config.input_keys[-1] + 1]
    # neat uses -1, -2 etc? To simplify, use config
    in_keys = list(config.genome_config.input_keys)
    out_keys = list(config.genome_config.output_keys)

    # get hidden nodes
    hidden_keys = [k for k in node_keys if (k not in in_keys) and (k not in out_keys)]

    layers = [in_keys, hidden_keys, out_keys]
    layer_x = [x0 + 10, x0 + w // 2, x0 + w - 20]
    # calculate vertical spacing
    max_nodes_in_layer = max(len(l) for l in layers if len(l) > 0)
    node_positions = {}
    for li, layer in enumerate(layers):
        cnt = len(layer)
        if cnt == 0:
            continue
        spacing = h / (cnt + 1)
        for ii, nk in enumerate(layer):
            posx = layer_x[li]
            posy = int(y0 + (ii + 1) * spacing)
            node_positions[nk] = (posx, posy)
            pygame.draw.circle(surface, (240, 240, 240), (posx, posy), 6)
            # node id small
            txt = font.render(str(nk), True, (10, 10, 10))
            surface.blit(txt, (posx - 6, posy - 6))

    # draw connections
    for cg_key, cg in genome.connections.items():
        if not cg.enabled:
            continue
        in_k = cg.key[0]
        out_k = cg.key[1]
        if in_k in node_positions and out_k in node_positions:
            x1, y1 = node_positions[in_k]
            x2, y2 = node_positions[out_k]
            # weight maps to line thickness
            wth = max(1, int(min(4, abs(cg.weight) * 2)))
            col = (0, 200, 0) if cg.weight > 0 else (200, 0, 0)
            pygame.draw.line(surface, col, (x1, y1), (x2, y2), wth)

    # border
    pygame.draw.rect(surface, (150, 150, 150), (x0, y0, w, h), 1)
    label = font.render('Current best network', True, (220, 220, 220))
    surface.blit(label, (x0 + 6, y0 + 4))


# Evaluate genomes using pygame visualization
def eval_genomes(genomes, config):
    # setup pygame
    pygame.init()
    screen = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
    clock = pygame.time.Clock()

    nets = {}
    dinos = {}
    ge = {}

    # create objects per genome
    for gid, genome in genomes:
        genome.fitness = 0.0
        nets[gid] = neat.nn.FeedForwardNetwork.create(genome, config)
        dinos[gid] = Dino()
        ge[gid] = genome

    obstacles = []
    spawn_timer = next_spawn_time_ms()
    elapsed_ms = 0
    generation_time_limit_ms = 60000  # 60 seconds hard cap

    run = True
    while run:
        dt = clock.tick(FPS)
        elapsed_ms += dt

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                os._exit(0)

        # spawn obstacles
        spawn_timer -= dt
        if spawn_timer <= 0:
            obstacles.append(spawn_obstacle())
            spawn_timer = next_spawn_time_ms()

        # update obstacles
        for ob in obstacles:
            ob.update()
        obstacles = [o for o in obstacles if o.x + o.width > -50]

        # update dinos
        alive_count = 0
        for gid, dino in list(dinos.items()):
            if not dino.alive:
                continue
            alive_count += 1

            # inputs to network:
            # 1) distance to next obstacle
            # 2) obstacle width
            # 3) obstacle height
            # 4) obstacle y (top)
            # 5) dino vertical velocity
            # If no obstacle, give large values
            if len(obstacles) > 0:
                # choose the nearest obstacle in front of the dino
                next_ob = None
                for ob in obstacles:
                    if ob.x + ob.width >= dino.x:
                        next_ob = ob
                        break
                if next_ob is None:
                    next_ob = obstacles[0]
                dist = max(0.0, next_ob.x - dino.x)
                ob_w = next_ob.width
                ob_h = next_ob.height
                ob_y = next_ob.y
            else:
                dist = 1000.0
                ob_w = 0
                ob_h = 0
                ob_y = 0

            # normalize inputs roughly
            inp = [dist / WINDOW_WIDTH, ob_w / 100.0, ob_h / 100.0, (GROUND_Y - ob_y) / WINDOW_HEIGHT, (dino.vel_y + 15) / 30.0]

            output = nets[gid].activate(inp)
            # one output: jump probability
            if output[0] > 0.5:
                dino.jump()

            dino.update()

            # collision
            drect = dino.rect()
            dead = False
            for ob in obstacles:
                if drect.colliderect(ob.rect()):
                    dead = True
                    break
            if dead:
                dino.alive = False
                ge[gid].fitness -= 1.0
            else:
                # reward for survival and forward distance
                ge[gid].fitness += 0.1
                dino.score += 1

        # stop condition: all dead or time cap
        if alive_count == 0 or elapsed_ms > generation_time_limit_ms:
            run = False

        # Visualization: draw everything
        screen.fill((30, 30, 30))
        # ground
        pygame.draw.line(screen, (200, 200, 200), (0, GROUND_Y), (WINDOW_WIDTH, GROUND_Y), 2)

        # draw obstacles
        for ob in obstacles:
            col = (80, 180, 80) if ob.kind == 'cactus' else (180, 80, 80)
            pygame.draw.rect(screen, col, ob.rect())

        # draw dinos (limit drawn to POP_MAX_DRAW for performance)
        drawn = 0
        for gid, dino in dinos.items():
            if not dino.alive:
                continue
            if drawn >= POP_MAX_DRAW:
                break
            pygame.draw.rect(screen, (100, 200, 250), dino.rect())
            drawn += 1

        # --- Current Best Tracking ---
        # inicializar si no existe
        if not hasattr(eval_genomes, "current_best_gid"):
            eval_genomes.current_best_gid = None
            eval_genomes.current_best_fitness = -1e9
            eval_genomes.current_best_genome = None

        # revisar si hay un nuevo líder con mayor fitness
        for gid, genome in genomes:
            if genome.fitness > eval_genomes.current_best_fitness:
                eval_genomes.current_best_fitness = genome.fitness
                eval_genomes.current_best_gid = gid
                eval_genomes.current_best_genome = genome

        # si el actual líder muere, elegir otro de los vivos con mejor fitness
        if eval_genomes.current_best_gid is not None:
            if eval_genomes.current_best_gid in dinos and not dinos[eval_genomes.current_best_gid].alive:
                alive_best = None
                alive_best_fit = -1e9
                for gid, dino in dinos.items():
                    if dino.alive and ge[gid].fitness > alive_best_fit:
                        alive_best_fit = ge[gid].fitness
                        alive_best = gid
                if alive_best is not None:
                    eval_genomes.current_best_gid = alive_best
                    eval_genomes.current_best_fitness = ge[alive_best].fitness
                    eval_genomes.current_best_genome = ge[alive_best]

        # dibujar la red del best actual (si existe)
        if eval_genomes.current_best_genome is not None:
            draw_network(screen, eval_genomes.current_best_genome, config,
                         topleft=(WINDOW_WIDTH - 220, 6), size=(210, 150))
        else:
            pygame.draw.rect(screen, (100, 100, 100), (WINDOW_WIDTH - 220, 6, 210, 150), 1)

        # small HUD
        font = pygame.font.SysFont(None, 20)
        gen_text = font.render('Gen: {}'.format(eval_genomes.generation), True, (220, 220, 220))
        alive_text = font.render('Alive: {}'.format(alive_count), True, (220, 220, 220))
        screen.blit(gen_text, (10, 10))
        screen.blit(alive_text, (10, 34))

        pygame.display.flip()

    pygame.event.pump()
    # assign final fitness back
    # genomes list already references genomes so fitness assigned earlier persists

# store generation number on the function so we can display it
eval_genomes.generation = 0


def run(config_file):
    config = neat.Config(neat.DefaultGenome, neat.DefaultReproduction,
                         neat.DefaultSpeciesSet, neat.DefaultStagnation,
                         config_file)
    p = neat.Population(config)

    # reporters (stdout)
    p.add_reporter(neat.StdOutReporter(True))
    stats = neat.StatisticsReporter()
    p.add_reporter(stats)

    # wrap eval to keep track of generation number
    def wrapped_eval(genomes, config_in):
        eval_genomes.generation = wrapped_eval.generation
        eval_genomes(genomes, config_in)
        wrapped_eval.generation += 1

    wrapped_eval.generation = 0

    # run for up to 5000 generations
    winner = p.run(wrapped_eval, 5000)

    # save winner
    with open('winner.pkl', 'wb') as f:
        pickle.dump(winner, f)
    print('\nBest genome saved to winner.pkl')


if __name__ == '__main__':
    # ensure config exists
    cfg_path = 'config-feedforward.txt'
    if not os.path.exists(cfg_path):
        with open(cfg_path, 'w') as f:
            f.write(DEFAULT_NEAT_CONFIG)
        print('Wrote default NEAT config to', cfg_path)

    run(cfg_path)
